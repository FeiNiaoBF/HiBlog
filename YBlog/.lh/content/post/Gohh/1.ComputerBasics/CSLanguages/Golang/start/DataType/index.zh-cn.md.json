{
    "sourceFile": "content/post/Gohh/1.ComputerBasics/CSLanguages/Golang/start/DataType/index.zh-cn.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 30,
            "patches": [
                {
                    "date": 1715565776498,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1715565782785,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,27 +12,28 @@\n ---\n \n \n ## Go 语言中的数据结构\n+\n ### 基础数据结构\n \n  1. **数组（Array）** - 由固定长度的相同类型元素组成的数据结构。\n  2. **切片（Slice）** - 由数组构成的动态长度序列，提供了更灵活的操作方式。\n  3. **映射（Map）** - 存储键值对的集合，用于快速检索数据。\n  4. **结构体（Struct）** - 可以包含不同类型字段的复合数据类型。\n \n-\n ### 其他数据结构和类型\n \n 1. **通道（Channel）** - 用于在 Go 协程之间进行通信的类型。\n 2. **接口（Interface）** - 定义对象的行为，是一种抽象类型。\n 3. **指针（Pointer）** - 存储变量的内存地址，用于直接访问内存中的值。\n \n #### 通道（Channel）\n+\n #### 接口（Interface）\n+\n #### 指针（Pointer）\n \n-\n ## 命名规范\n \n 注意：\n > **首字母大小写：** 以大写字母开头的标识符是 **public** 的（可导出的），可以被其他包访问。以小写字母开头的标识符是私有的，只能在当前包内访问。\n@@ -47,9 +48,8 @@\n 6. **结构体**：结构体的命名同样使用驼峰命名法，例如 `type MyStruct struct`。\n 7. **接口**：接口的命名同样使用驼峰命名法，例如 `type MyInterface interface`。\n 8. **枚举**：枚举的命名同样使用驼峰命名法，例如 `type Color int`。\n \n-\n 在 Go 语言中，命名变量时有一些常见的命名规范，这些规范有助于编写清晰、易读的代码。\n \n 1. 使用驼峰命名法：变量名应该使用驼峰命名法，即除第一个单词外，其余单词的首字母大写，例如 `myVariable`。\n 2. 使用有意义的名称：变量名应该具有描述性，能够清晰地表达变量的用途和含义。\n@@ -58,5 +58,4 @@\n 5. 使用全大写命名的常量：在 Go 语言中，全大写的变量名通常用于表示常量。\n 6. 遵循约定俗成的命名规范：Go 语言社区有一些常见的命名约定，比如用 `i` 表示循环变量，用 `err` 表示错误变量等，建议遵循这些约定以保持代码风格的一致性。\n \n 这些命名规范有助于编写清晰、易读的代码，并且有助于提高代码的可维护性。\n-\n"
                },
                {
                    "date": 1715565788494,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,8 @@\n ---\n title: \"DataType\"\n date: 2024-05-13T09:10:19+08:00\n-draft: true\n+draft: false\n taps: []\n categories: []\n author: [\"Yeelight\"]\n showtoc: true\n"
                },
                {
                    "date": 1715565795300,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,10 +1,10 @@\n ---\n title: \"DataType\"\n date: 2024-05-13T09:10:19+08:00\n draft: false\n-taps: []\n-categories: []\n+taps: [\"Golang\", \"start\"]\n+categories: [\"Golang\", \"CS\", \"Languages\"]\n author: [\"Yeelight\"]\n showtoc: true\n weight:\n math: false\n"
                },
                {
                    "date": 1716172904011,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,9 +2,9 @@\n title: \"DataType\"\n date: 2024-05-13T09:10:19+08:00\n draft: false\n taps: [\"Golang\", \"start\"]\n-categories: [\"Golang\", \"CS\", \"Languages\"]\n+categories: [\"Golang\", \"CS\"]\n author: [\"Yeelight\"]\n showtoc: true\n weight:\n math: false\n@@ -26,14 +26,9 @@\n 1. **通道（Channel）** - 用于在 Go 协程之间进行通信的类型。\n 2. **接口（Interface）** - 定义对象的行为，是一种抽象类型。\n 3. **指针（Pointer）** - 存储变量的内存地址，用于直接访问内存中的值。\n \n-#### 通道（Channel）\n \n-#### 接口（Interface）\n-\n-#### 指针（Pointer）\n-\n ## 命名规范\n \n 注意：\n > **首字母大小写：** 以大写字母开头的标识符是 **public** 的（可导出的），可以被其他包访问。以小写字母开头的标识符是私有的，只能在当前包内访问。\n"
                },
                {
                    "date": 1716172910265,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -45,12 +45,4 @@\n 8. **枚举**：枚举的命名同样使用驼峰命名法，例如 `type Color int`。\n \n 在 Go 语言中，命名变量时有一些常见的命名规范，这些规范有助于编写清晰、易读的代码。\n \n-1. 使用驼峰命名法：变量名应该使用驼峰命名法，即除第一个单词外，其余单词的首字母大写，例如 `myVariable`。\n-2. 使用有意义的名称：变量名应该具有描述性，能够清晰地表达变量的用途和含义。\n-3. 避免使用单个字符作为变量名：除非是临时变量或者循环变量，否则应该避免使用单个字符作为变量名，以提高代码的可读性。\n-4. 使用短小的名称：变量名应该尽量简洁，但又能清晰表达变量的含义。\n-5. 使用全大写命名的常量：在 Go 语言中，全大写的变量名通常用于表示常量。\n-6. 遵循约定俗成的命名规范：Go 语言社区有一些常见的命名约定，比如用 `i` 表示循环变量，用 `err` 表示错误变量等，建议遵循这些约定以保持代码风格的一致性。\n-\n-这些命名规范有助于编写清晰、易读的代码，并且有助于提高代码的可维护性。\n"
                },
                {
                    "date": 1716172917311,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -30,9 +30,9 @@\n \n ## 命名规范\n \n 注意：\n-> **首字母大小写：** 以大写字母开头的标识符是 **public** 的（可导出的），可以被其他包访问。以小写字母开头的标识符是私有的，只能在当前包内访问。\n+> **首字母大小写** 以大写字母开头的标识符是 **public** 的（可导出的），可以被其他包访问。以小写字母开头的标识符是私有的，只能在当前包内访问。\n \n 在 Go 语言中，有一些命名规范适用于不同的命名情况。以下是一些常见的命名规范：\n \n 1. **包名**：包名应该使用单数形式，且应该是小写的，例如 `utils`。\n@@ -42,7 +42,4 @@\n 5. **函数**：函数名同样使用驼峰命名法，例如 `calculateTotal`。\n 6. **结构体**：结构体的命名同样使用驼峰命名法，例如 `type MyStruct struct`。\n 7. **接口**：接口的命名同样使用驼峰命名法，例如 `type MyInterface interface`。\n 8. **枚举**：枚举的命名同样使用驼峰命名法，例如 `type Color int`。\n-\n-在 Go 语言中，命名变量时有一些常见的命名规范，这些规范有助于编写清晰、易读的代码。\n-\n"
                },
                {
                    "date": 1716172925422,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -30,9 +30,9 @@\n \n ## 命名规范\n \n 注意：\n-> **首字母大小写** 以大写字母开头的标识符是 **public** 的（可导出的），可以被其他包访问。以小写字母开头的标识符是私有的，只能在当前包内访问。\n+> **首字母大小写：** 以大写字母开头的标识符是 **public** 的（可导出的），可以被其他包访问。以小写字母开头的标识符是私有的，只能在当前包内访问。\n \n 在 Go 语言中，有一些命名规范适用于不同的命名情况。以下是一些常见的命名规范：\n \n 1. **包名**：包名应该使用单数形式，且应该是小写的，例如 `utils`。\n@@ -42,4 +42,183 @@\n 5. **函数**：函数名同样使用驼峰命名法，例如 `calculateTotal`。\n 6. **结构体**：结构体的命名同样使用驼峰命名法，例如 `type MyStruct struct`。\n 7. **接口**：接口的命名同样使用驼峰命名法，例如 `type MyInterface interface`。\n 8. **枚举**：枚举的命名同样使用驼峰命名法，例如 `type Color int`。\n+\n+> 目前（Go 1.21），Go有26个类型种类。\n+\n+## 类型\n+\n+### 类型定义（type definition declaration）\n+\n+用如下形式来定义新的类型。`type`为一个关键字。\n+```go\n+// 定义单个类型。\n+type NewTypeName SourceType\n+\n+// 定义多个类型（将多个类型描述合并在一个声明中）。\n+type (\n+\tNewTypeName1 SourceType1\n+\tNewTypeName2 SourceType2\n+)\n+```\n+\n+- 一个新定义的类型和它的源类型为两个不同的类型。\n+- 在两个不同的类型定义中所定义的两个类型肯定是两个不同的类型。\n+- 一个新定义的类型和它的源类型的底层类型一致并且它们的值可以相互显式转换。\n+- 类型定义可以出现在函数体内（局部）。\n+\n+> 请注意：从Go 1.9到Go 1.17，Go白皮书曾经把预声明类型视为定义类型。 但是从Go 1.18开始，Go白皮书明确说明预声明类型不再属于定义类型。\n+\n+### 具名类型\n+\n+> 在Go 1.9之前，**具名类型**这个术语在Go白皮书中是精确定义的。 在那时，一个具名类型被定义为一个可以用标识符表示的类型。 随着在Go 1.9中引入了自定义类型别名（见下一节），**具名类型**这个术语被从白皮书中删除了；取而代之的是**定义类型**。 随着Go 1.18中引入了自定义泛型，**具名类型**这个术语又被重新加回到白皮书。\n+\n+一个具名类型可能为\n+- 一个预声明类型；\n+- 一个定义（非自定义泛型）类型；\n+- 一个（泛型类型的）实例化类型；\n+- 一个类型参数类型（使用在自定义泛型中）。\n+\n+其它类型称为无名类型。一个无名类型肯定是一个组合类型（反之则未必）。\n+\n+### 类型别名声明\n+\n+```go\n+type (\n+\tName = string\n+\tAge  = int\n+)\n+\n+type table = map[string]int\n+type Table = map[Name]Age\n+```\n+其中 `map[string]int` 和 `map[Name]Age` 表示同一类型\n+\n+### 底层类型（underlying type）\n+\n+规则：\n+\n+- 一个内置类型的底层类型为它自己。\n+- `unsafe`标准库包中定义的`Pointer`类型的底层类型是它自己。 （至少我们可以认为是这样。事实上，关于`unsafe.Pointer`类型的底层类型，官方文档中并没有清晰的说明。我们也可以认为`unsafe.Pointer`类型的底层类型为`*T`，其中`T`表示一个任意类型。） `unsafe.Pointer`也被视为一个内置类型。\n+- 一个无名类型（必为一个组合类型）的底层类型为它自己。\n+- 在一个类型声明中，新声明的类型和源类型共享底层类型。\n+\n+```go\n+// 这四个类型的底层类型均为内置类型int。\n+type (\n+\tMyInt int\n+\tAge   MyInt\n+)\n+\n+// 下面这三个新声明的类型的底层类型各不相同。\n+type (\n+\tIntSlice   []int   // 底层类型为[]int\n+\tMyIntSlice []MyInt // 底层类型为[]MyInt\n+\tAgeSlice   []Age   // 底层类型为[]Age\n+)\n+\n+// 类型[]Age、Ages和AgeSlice的底层类型均为[]Age。\n+type Ages AgeSlice\n+```\n+\n+#### 在 Go 中，\n+- 底层类型为内置类型`bool`的类型称为**布尔类型**；\n+- 底层类型为任一内置整数类型的类型称为**整数类型**；\n+- 底层类型为内置类型`float32`或者`float64`的类型称为**浮点数类型**；\n+- 底层类型为内置类型`complex64`或`complex128`的类型称为**复数类型**；\n+- 整数类型、浮点数类型和复数类型统称为**数字值类型**；\n+- 底层类型为内置类型`string`的类型称为**字符串类型**。\n+\n+## 值（value）\n+\n+一个类型的一个实例称为此类型的一个值。一个类型可以有很多不同的值，其中一个为它的零值。同一类型的不同值共享很多相同的属性。\n+\n+每个类型有一个零值。一个类型的零值可以看作是此类型的默认值。预声明的标识符 `nil` 可以看作是切片、映射、函数、通道、指针（包括非类型安全指针）和接口类型的零值的字面量表示。\n+\n+值分为类型确定的和类型不确定的。\n+\n+Go 中还有另外两种的字面量表示形式：函数字面量表示形式和组合字面量表示形式（composite literal）。\n+- 函数字面量表示形式用来表示函数值。事实上，一个函数声明是由一个**标识符**（函数名）和一个**函数字面量**表示形式组成。\n+- 组合字面量表示形式用来表示**结构体类型值**和**容器类型**（数组、切片和映射）值。\n+\n+### 值部（value part）\n+>这个术语并没有在 Go 白皮书中定义。它仅使用在 _《Go 语言101》_ 这本书中，用来简化一些解释并帮助 Go 程序员更好地理解 Go 类型和值。\n+\n+in run time, 很多值是存储在**内存**的。每个这样的值都有一个**直接部分**，但是有一些值还可能有一个或多个**间接部分**。每个值部分在内存中都占据一段连续空间。\n+\n+### 值尺寸（value size）\n+> Go白皮书没有规定非数值类型值的尺寸。\n+\n+一个值存储在内存中是要占据一定的空间的。此空间的大小称为此值的尺寸。值尺寸是用字节数来衡量的。 在Go中，当我们谈及一个值的尺寸，如果没有特殊说明，我们一般是指此值的直接部分的尺寸。 某个特定类别的所有类型的值的尺寸都是一样的。因为这个原因，我们也常将一个值的尺寸说成是它的类型的尺寸（或值尺寸）。\n+\n+\n+## 其他概念\n+\n+### 指针类型的基类型（base type）\n+\n+若一个指针类型的底层类型表示为 `*T`，则此指针类型的基类型为 `T` 所表示的类型。\n+\n+### 结构体类型的字段（field）\n+\n+一个结构体类型由若干成员变量组成。每个这样的成员变量称为此结构体的一个字段。\n+### 函数类型的签名（signature）\n+\n+一个函数和其类型的签名由此函数的**输入参数**和**返回结果**的类型列表组成。函数名称和函数体不属于函数签名的构成部分。\n+如：\n+```go\n+\tWrite(p []byte) (n int, err error)\n+```\n+### 类型的方法（method）和方法集（method set）\n+\n+在 Go 中，我们可以给满足某些条件的类型（构造器）声明方法。方法也常被称为成员函数。一个类型的所有方法组成了此类型的**方法集**。\n+\n+### 接口类型的动态类型和动态值\n+\n+接口类型的值称为**接口值**。一个接口值可以包裹装载一个非接口值。_包裹在一个接口值中的非接口值称为此接口值的动态值_。此动态值的类型称为此接口值的动态类型。 一个什么也没包裹的接口值为一个零值接口值。零值接口值的动态值和动态类型均为不存在。\n+一个接口类型可以指定若干个（可以是零个）方法，这些方法形成了此接口类型的方法集。\n+如果一个类型（可以是接口或者非接口类型）的方法集是一个接口类型的方法集的超集，则我们说此类型实现了此接口类型。\n+\n+### 一个值的具体类型（concrete type）和具体值（concrete value）\n+\n+对于一个（类型确定的）非接口值，它的具体类型就是它的类型，它的具体值就是它自己。\n+一个 _零值接口值_ 没有具体类型和具体值。对于一个非零值接口值，它的具体类型和具体值就是它的动态类型和动态值。\n+\n+### 容器类型\n+\n+**数组** `[]int`、**切片** `slice`   和**映射** `map` 是 Go 中的三种正式意义上的内置容器类型。\n+有时候，**字符串**和**通道类型**也可以被非正式地看作是容器类型。\n+（正式和非正式的）容器类型的每个值都有一个**长度属性**。\n+\n+### 映射类型的键值（key）类型\n+\n+如果一个映射类型的底层类型表示为 `map[Tkey]T`，则此映射类型的键值类型为 `Tkey`。 `Tkey` 必须为一个**可比较类型** 。\n+\n+### 容器类型的元素（element）类型\n+\n+存储在一个容器值中的所有元素的类型必须为同一个类型。此同一类型称为此容器值的（容器）类型的元素类型。\n+\n+### 通道类型的方向\n+\n+一个通道值可以被看作是 **先入先出（first-in-first-out，FIFO）** 队列。一个通道值可能是可读可写的、只读的（receive-only）或者只写的（send-only）。\n+- 一个可读可写的通道值也称为一个双向通道。 一个双向通道类型的底层类型可以被表示为`chan T`。\n+- 我们只能向一个只写的通道值发送数据，而不能从其中接收数据。 只写通道类型的底层类型可以被表示为`chan<- T`。\n+- 我们只能从一个只读的通道值接收数据，而不能向其发送数据。 只读通道类型的底层类型可以被表示为`<-chan T`。\n+\n+## 值得提的事\n+\n+### 可比较类型和不可比较类型\n+\n+目前（~~Go 1.21~~），下面这些类型的值不支持（使用 `==` 和 `!=` 运算标识符）比较。这些类型称为 _不可比较类型_。\n+- 切片类型\n+- 映射类型\n+- 函数类型\n+- 任何包含有不可比较类型的字段的结构体类型和任何元素类型为不可比较类型的数组类型。\n+其它类型称为可比较类型。\n+映射类型的键值类型必须为可比较类型。\n+\n+## 外部链接\n+\n+[Go 101](https://gfw.go101.org/article/type-system-overview.html)\n+\n+\n+\n"
                },
                {
                    "date": 1716172935420,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -26,9 +26,8 @@\n 1. **通道（Channel）** - 用于在 Go 协程之间进行通信的类型。\n 2. **接口（Interface）** - 定义对象的行为，是一种抽象类型。\n 3. **指针（Pointer）** - 存储变量的内存地址，用于直接访问内存中的值。\n \n-\n ## 命名规范\n \n 注意：\n > **首字母大小写：** 以大写字母开头的标识符是 **public** 的（可导出的），可以被其他包访问。以小写字母开头的标识符是私有的，只能在当前包内访问。\n@@ -50,16 +49,17 @@\n \n ### 类型定义（type definition declaration）\n \n 用如下形式来定义新的类型。`type`为一个关键字。\n+\n ```go\n // 定义单个类型。\n type NewTypeName SourceType\n \n // 定义多个类型（将多个类型描述合并在一个声明中）。\n type (\n-\tNewTypeName1 SourceType1\n-\tNewTypeName2 SourceType2\n+ NewTypeName1 SourceType1\n+ NewTypeName2 SourceType2\n )\n ```\n \n - 一个新定义的类型和它的源类型为两个不同的类型。\n@@ -73,8 +73,9 @@\n \n > 在Go 1.9之前，**具名类型**这个术语在Go白皮书中是精确定义的。 在那时，一个具名类型被定义为一个可以用标识符表示的类型。 随着在Go 1.9中引入了自定义类型别名（见下一节），**具名类型**这个术语被从白皮书中删除了；取而代之的是**定义类型**。 随着Go 1.18中引入了自定义泛型，**具名类型**这个术语又被重新加回到白皮书。\n \n 一个具名类型可能为\n+\n - 一个预声明类型；\n - 一个定义（非自定义泛型）类型；\n - 一个（泛型类型的）实例化类型；\n - 一个类型参数类型（使用在自定义泛型中）。\n@@ -84,15 +85,16 @@\n ### 类型别名声明\n \n ```go\n type (\n-\tName = string\n-\tAge  = int\n+ Name = string\n+ Age  = int\n )\n \n type table = map[string]int\n type Table = map[Name]Age\n ```\n+\n 其中 `map[string]int` 和 `map[Name]Age` 表示同一类型\n \n ### 底层类型（underlying type）\n \n@@ -105,24 +107,25 @@\n \n ```go\n // 这四个类型的底层类型均为内置类型int。\n type (\n-\tMyInt int\n-\tAge   MyInt\n+ MyInt int\n+ Age   MyInt\n )\n \n // 下面这三个新声明的类型的底层类型各不相同。\n type (\n-\tIntSlice   []int   // 底层类型为[]int\n-\tMyIntSlice []MyInt // 底层类型为[]MyInt\n-\tAgeSlice   []Age   // 底层类型为[]Age\n+ IntSlice   []int   // 底层类型为[]int\n+ MyIntSlice []MyInt // 底层类型为[]MyInt\n+ AgeSlice   []Age   // 底层类型为[]Age\n )\n \n // 类型[]Age、Ages和AgeSlice的底层类型均为[]Age。\n type Ages AgeSlice\n ```\n \n-#### 在 Go 中，\n+#### 在 Go 中\n+\n - 底层类型为内置类型`bool`的类型称为**布尔类型**；\n - 底层类型为任一内置整数类型的类型称为**整数类型**；\n - 底层类型为内置类型`float32`或者`float64`的类型称为**浮点数类型**；\n - 底层类型为内置类型`complex64`或`complex128`的类型称为**复数类型**；\n@@ -137,22 +140,24 @@\n \n 值分为类型确定的和类型不确定的。\n \n Go 中还有另外两种的字面量表示形式：函数字面量表示形式和组合字面量表示形式（composite literal）。\n+\n - 函数字面量表示形式用来表示函数值。事实上，一个函数声明是由一个**标识符**（函数名）和一个**函数字面量**表示形式组成。\n - 组合字面量表示形式用来表示**结构体类型值**和**容器类型**（数组、切片和映射）值。\n \n ### 值部（value part）\n+>\n >这个术语并没有在 Go 白皮书中定义。它仅使用在 _《Go 语言101》_ 这本书中，用来简化一些解释并帮助 Go 程序员更好地理解 Go 类型和值。\n \n in run time, 很多值是存储在**内存**的。每个这样的值都有一个**直接部分**，但是有一些值还可能有一个或多个**间接部分**。每个值部分在内存中都占据一段连续空间。\n \n ### 值尺寸（value size）\n+>\n > Go白皮书没有规定非数值类型值的尺寸。\n \n 一个值存储在内存中是要占据一定的空间的。此空间的大小称为此值的尺寸。值尺寸是用字节数来衡量的。 在Go中，当我们谈及一个值的尺寸，如果没有特殊说明，我们一般是指此值的直接部分的尺寸。 某个特定类别的所有类型的值的尺寸都是一样的。因为这个原因，我们也常将一个值的尺寸说成是它的类型的尺寸（或值尺寸）。\n \n-\n ## 其他概念\n \n ### 指针类型的基类型（base type）\n \n@@ -160,15 +165,18 @@\n \n ### 结构体类型的字段（field）\n \n 一个结构体类型由若干成员变量组成。每个这样的成员变量称为此结构体的一个字段。\n+\n ### 函数类型的签名（signature）\n \n 一个函数和其类型的签名由此函数的**输入参数**和**返回结果**的类型列表组成。函数名称和函数体不属于函数签名的构成部分。\n 如：\n+\n ```go\n-\tWrite(p []byte) (n int, err error)\n+ Write(p []byte) (n int, err error)\n ```\n+\n ### 类型的方法（method）和方法集（method set）\n \n 在 Go 中，我们可以给满足某些条件的类型（构造器）声明方法。方法也常被称为成员函数。一个类型的所有方法组成了此类型的**方法集**。\n \n@@ -199,8 +207,9 @@\n \n ### 通道类型的方向\n \n 一个通道值可以被看作是 **先入先出（first-in-first-out，FIFO）** 队列。一个通道值可能是可读可写的、只读的（receive-only）或者只写的（send-only）。\n+\n - 一个可读可写的通道值也称为一个双向通道。 一个双向通道类型的底层类型可以被表示为`chan T`。\n - 我们只能向一个只写的通道值发送数据，而不能从其中接收数据。 只写通道类型的底层类型可以被表示为`chan<- T`。\n - 我们只能从一个只读的通道值接收数据，而不能向其发送数据。 只读通道类型的底层类型可以被表示为`<-chan T`。\n \n@@ -208,8 +217,9 @@\n \n ### 可比较类型和不可比较类型\n \n 目前（~~Go 1.21~~），下面这些类型的值不支持（使用 `==` 和 `!=` 运算标识符）比较。这些类型称为 _不可比较类型_。\n+\n - 切片类型\n - 映射类型\n - 函数类型\n - 任何包含有不可比较类型的字段的结构体类型和任何元素类型为不可比较类型的数组类型。\n@@ -218,7 +228,4 @@\n \n ## 外部链接\n \n [Go 101](https://gfw.go101.org/article/type-system-overview.html)\n-\n-\n-\n"
                },
                {
                    "date": 1716172944982,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,26 +1,25 @@\n ---\n-title: \"DataType\"\n+title: 'DataType'\n date: 2024-05-13T09:10:19+08:00\n draft: false\n-taps: [\"Golang\", \"start\"]\n-categories: [\"Golang\", \"CS\"]\n-author: [\"Yeelight\"]\n+taps: ['Golang', 'start']\n+categories: ['Golang', 'CS']\n+author: ['Yeelight']\n showtoc: true\n weight:\n math: false\n readingTime: true\n ---\n \n-\n ## Go 语言中的数据结构\n \n ### 基础数据结构\n \n- 1. **数组（Array）** - 由固定长度的相同类型元素组成的数据结构。\n- 2. **切片（Slice）** - 由数组构成的动态长度序列，提供了更灵活的操作方式。\n- 3. **映射（Map）** - 存储键值对的集合，用于快速检索数据。\n- 4. **结构体（Struct）** - 可以包含不同类型字段的复合数据类型。\n+1. **数组（Array）** - 由固定长度的相同类型元素组成的数据结构。\n+2. **切片（Slice）** - 由数组构成的动态长度序列，提供了更灵活的操作方式。\n+3. **映射（Map）** - 存储键值对的集合，用于快速检索数据。\n+4. **结构体（Struct）** - 可以包含不同类型字段的复合数据类型。\n \n ### 其他数据结构和类型\n \n 1. **通道（Channel）** - 用于在 Go 协程之间进行通信的类型。\n@@ -29,8 +28,9 @@\n \n ## 命名规范\n \n 注意：\n+\n > **首字母大小写：** 以大写字母开头的标识符是 **public** 的（可导出的），可以被其他包访问。以小写字母开头的标识符是私有的，只能在当前包内访问。\n \n 在 Go 语言中，有一些命名规范适用于不同的命名情况。以下是一些常见的命名规范：\n \n@@ -42,9 +42,9 @@\n 6. **结构体**：结构体的命名同样使用驼峰命名法，例如 `type MyStruct struct`。\n 7. **接口**：接口的命名同样使用驼峰命名法，例如 `type MyInterface interface`。\n 8. **枚举**：枚举的命名同样使用驼峰命名法，例如 `type Color int`。\n \n-> 目前（Go 1.21），Go有26个类型种类。\n+> 目前（Go 1.21），Go 有 26 个类型种类。\n \n ## 类型\n \n ### 类型定义（type definition declaration）\n@@ -66,13 +66,13 @@\n - 在两个不同的类型定义中所定义的两个类型肯定是两个不同的类型。\n - 一个新定义的类型和它的源类型的底层类型一致并且它们的值可以相互显式转换。\n - 类型定义可以出现在函数体内（局部）。\n \n-> 请注意：从Go 1.9到Go 1.17，Go白皮书曾经把预声明类型视为定义类型。 但是从Go 1.18开始，Go白皮书明确说明预声明类型不再属于定义类型。\n+> 请注意：从 Go 1.9 到 Go 1.17，Go 白皮书曾经把预声明类型视为定义类型。 但是从 Go 1.18 开始，Go 白皮书明确说明预声明类型不再属于定义类型。\n \n ### 具名类型\n \n-> 在Go 1.9之前，**具名类型**这个术语在Go白皮书中是精确定义的。 在那时，一个具名类型被定义为一个可以用标识符表示的类型。 随着在Go 1.9中引入了自定义类型别名（见下一节），**具名类型**这个术语被从白皮书中删除了；取而代之的是**定义类型**。 随着Go 1.18中引入了自定义泛型，**具名类型**这个术语又被重新加回到白皮书。\n+> 在 Go 1.9 之前，**具名类型**这个术语在 Go 白皮书中是精确定义的。 在那时，一个具名类型被定义为一个可以用标识符表示的类型。 随着在 Go 1.9 中引入了自定义类型别名（见下一节），**具名类型**这个术语被从白皮书中删除了；取而代之的是**定义类型**。 随着 Go 1.18 中引入了自定义泛型，**具名类型**这个术语又被重新加回到白皮书。\n \n 一个具名类型可能为\n \n - 一个预声明类型；\n@@ -145,19 +145,19 @@\n - 函数字面量表示形式用来表示函数值。事实上，一个函数声明是由一个**标识符**（函数名）和一个**函数字面量**表示形式组成。\n - 组合字面量表示形式用来表示**结构体类型值**和**容器类型**（数组、切片和映射）值。\n \n ### 值部（value part）\n->\n->这个术语并没有在 Go 白皮书中定义。它仅使用在 _《Go 语言101》_ 这本书中，用来简化一些解释并帮助 Go 程序员更好地理解 Go 类型和值。\n \n+> 这个术语并没有在 Go 白皮书中定义。它仅使用在 _《Go 语言 101》_ 这本书中，用来简化一些解释并帮助 Go 程序员更好地理解 Go 类型和值。\n+\n in run time, 很多值是存储在**内存**的。每个这样的值都有一个**直接部分**，但是有一些值还可能有一个或多个**间接部分**。每个值部分在内存中都占据一段连续空间。\n \n ### 值尺寸（value size）\n->\n-> Go白皮书没有规定非数值类型值的尺寸。\n \n-一个值存储在内存中是要占据一定的空间的。此空间的大小称为此值的尺寸。值尺寸是用字节数来衡量的。 在Go中，当我们谈及一个值的尺寸，如果没有特殊说明，我们一般是指此值的直接部分的尺寸。 某个特定类别的所有类型的值的尺寸都是一样的。因为这个原因，我们也常将一个值的尺寸说成是它的类型的尺寸（或值尺寸）。\n+> Go 白皮书没有规定非数值类型值的尺寸。\n \n+一个值存储在内存中是要占据一定的空间的。此空间的大小称为此值的尺寸。值尺寸是用字节数来衡量的。 在 Go 中，当我们谈及一个值的尺寸，如果没有特殊说明，我们一般是指此值的直接部分的尺寸。 某个特定类别的所有类型的值的尺寸都是一样的。因为这个原因，我们也常将一个值的尺寸说成是它的类型的尺寸（或值尺寸）。\n+\n ## 其他概念\n \n ### 指针类型的基类型（base type）\n \n@@ -192,9 +192,9 @@\n 一个 _零值接口值_ 没有具体类型和具体值。对于一个非零值接口值，它的具体类型和具体值就是它的动态类型和动态值。\n \n ### 容器类型\n \n-**数组** `[]int`、**切片** `slice`   和**映射** `map` 是 Go 中的三种正式意义上的内置容器类型。\n+**数组** `[]int`、**切片** `slice` 和**映射** `map` 是 Go 中的三种正式意义上的内置容器类型。\n 有时候，**字符串**和**通道类型**也可以被非正式地看作是容器类型。\n （正式和非正式的）容器类型的每个值都有一个**长度属性**。\n \n ### 映射类型的键值（key）类型\n@@ -222,10 +222,10 @@\n - 切片类型\n - 映射类型\n - 函数类型\n - 任何包含有不可比较类型的字段的结构体类型和任何元素类型为不可比较类型的数组类型。\n-其它类型称为可比较类型。\n-映射类型的键值类型必须为可比较类型。\n+  其它类型称为可比较类型。\n+  映射类型的键值类型必须为可比较类型。\n \n ## 外部链接\n \n [Go 101](https://gfw.go101.org/article/type-system-overview.html)\n"
                },
                {
                    "date": 1716173020264,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -66,9 +66,8 @@\n - 在两个不同的类型定义中所定义的两个类型肯定是两个不同的类型。\n - 一个新定义的类型和它的源类型的底层类型一致并且它们的值可以相互显式转换。\n - 类型定义可以出现在函数体内（局部）。\n \n-> 请注意：从 Go 1.9 到 Go 1.17，Go 白皮书曾经把预声明类型视为定义类型。 但是从 Go 1.18 开始，Go 白皮书明确说明预声明类型不再属于定义类型。\n \n ### 具名类型\n \n > 在 Go 1.9 之前，**具名类型**这个术语在 Go 白皮书中是精确定义的。 在那时，一个具名类型被定义为一个可以用标识符表示的类型。 随着在 Go 1.9 中引入了自定义类型别名（见下一节），**具名类型**这个术语被从白皮书中删除了；取而代之的是**定义类型**。 随着 Go 1.18 中引入了自定义泛型，**具名类型**这个术语又被重新加回到白皮书。\n"
                },
                {
                    "date": 1716173039517,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -66,13 +66,10 @@\n - 在两个不同的类型定义中所定义的两个类型肯定是两个不同的类型。\n - 一个新定义的类型和它的源类型的底层类型一致并且它们的值可以相互显式转换。\n - 类型定义可以出现在函数体内（局部）。\n \n-\n ### 具名类型\n \n-> 在 Go 1.9 之前，**具名类型**这个术语在 Go 白皮书中是精确定义的。 在那时，一个具名类型被定义为一个可以用标识符表示的类型。 随着在 Go 1.9 中引入了自定义类型别名（见下一节），**具名类型**这个术语被从白皮书中删除了；取而代之的是**定义类型**。 随着 Go 1.18 中引入了自定义泛型，**具名类型**这个术语又被重新加回到白皮书。\n-\n 一个具名类型可能为\n \n - 一个预声明类型；\n - 一个定义（非自定义泛型）类型；\n"
                },
                {
                    "date": 1716173045933,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -75,9 +75,9 @@\n - 一个定义（非自定义泛型）类型；\n - 一个（泛型类型的）实例化类型；\n - 一个类型参数类型（使用在自定义泛型中）。\n \n-其它类型称为无名类型。一个无名类型肯定是一个组合类型（反之则未必）。\n+其它类型称为*无名类型。一个无名类型肯定是一个组合类型（反之则未必）。\n \n ### 类型别名声明\n \n ```go\n"
                },
                {
                    "date": 1716173054754,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -75,9 +75,9 @@\n - 一个定义（非自定义泛型）类型；\n - 一个（泛型类型的）实例化类型；\n - 一个类型参数类型（使用在自定义泛型中）。\n \n-其它类型称为*无名类型。一个无名类型肯定是一个组合类型（反之则未必）。\n+其它类型称为*无名类型*。一个无名类型肯定是一个*组合类型*（反之则未必）。\n \n ### 类型别名声明\n \n ```go\n"
                },
                {
                    "date": 1716173062872,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -66,9 +66,9 @@\n - 在两个不同的类型定义中所定义的两个类型肯定是两个不同的类型。\n - 一个新定义的类型和它的源类型的底层类型一致并且它们的值可以相互显式转换。\n - 类型定义可以出现在函数体内（局部）。\n \n-### 具名类型\n+### 具名类型()\n \n 一个具名类型可能为\n \n - 一个预声明类型；\n"
                },
                {
                    "date": 1716173068080,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -66,9 +66,9 @@\n - 在两个不同的类型定义中所定义的两个类型肯定是两个不同的类型。\n - 一个新定义的类型和它的源类型的底层类型一致并且它们的值可以相互显式转换。\n - 类型定义可以出现在函数体内（局部）。\n \n-### 具名类型()\n+### 具名类型(named ty)\n \n 一个具名类型可能为\n \n - 一个预声明类型；\n"
                },
                {
                    "date": 1716173224526,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -66,9 +66,9 @@\n - 在两个不同的类型定义中所定义的两个类型肯定是两个不同的类型。\n - 一个新定义的类型和它的源类型的底层类型一致并且它们的值可以相互显式转换。\n - 类型定义可以出现在函数体内（局部）。\n \n-### 具名类型(named ty)\n+### 具名类型(named type)\n \n 一个具名类型可能为\n \n - 一个预声明类型；\n@@ -77,8 +77,9 @@\n - 一个类型参数类型（使用在自定义泛型中）。\n \n 其它类型称为*无名类型*。一个无名类型肯定是一个*组合类型*（反之则未必）。\n \n+\n ### 类型别名声明\n \n ```go\n type (\n"
                },
                {
                    "date": 1716173232300,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -76,10 +76,10 @@\n - 一个（泛型类型的）实例化类型；\n - 一个类型参数类型（使用在自定义泛型中）。\n \n 其它类型称为*无名类型*。一个无名类型肯定是一个*组合类型*（反之则未必）。\n+[Named and Unnamed Types](https://stackoverflow.com/questions/32983546/named-and-unnamed-types)\n \n-\n ### 类型别名声明\n \n ```go\n type (\n"
                },
                {
                    "date": 1716173246951,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -75,9 +75,9 @@\n - 一个定义（非自定义泛型）类型；\n - 一个（泛型类型的）实例化类型；\n - 一个类型参数类型（使用在自定义泛型中）。\n \n-其它类型称为*无名类型*。一个无名类型肯定是一个*组合类型*（反之则未必）。\n+其它类型称为*无名类型*。一个无名类型肯定是一个*组合类型*\n [Named and Unnamed Types](https://stackoverflow.com/questions/32983546/named-and-unnamed-types)\n \n ### 类型别名声明\n \n"
                },
                {
                    "date": 1716173285012,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -75,9 +75,9 @@\n - 一个定义（非自定义泛型）类型；\n - 一个（泛型类型的）实例化类型；\n - 一个类型参数类型（使用在自定义泛型中）。\n \n-其它类型称为*无名类型*。一个无名类型肯定是一个*组合类型*\n+其它类型称为*无名类型*。一个无名类型肯定是一个*组合类型*。\n [Named and Unnamed Types](https://stackoverflow.com/questions/32983546/named-and-unnamed-types)\n \n ### 类型别名声明\n \n@@ -97,9 +97,9 @@\n \n 规则：\n \n - 一个内置类型的底层类型为它自己。\n-- `unsafe`标准库包中定义的`Pointer`类型的底层类型是它自己。 （至少我们可以认为是这样。事实上，关于`unsafe.Pointer`类型的底层类型，官方文档中并没有清晰的说明。我们也可以认为`unsafe.Pointer`类型的底层类型为`*T`，其中`T`表示一个任意类型。） `unsafe.Pointer`也被视为一个内置类型。\n+- `unsafe`标准库包中定义的`Pointer`类型的底层类型是它自己。 `unsafe.Pointer`也被视为一个内置类型。\n - 一个无名类型（必为一个组合类型）的底层类型为它自己。\n - 在一个类型声明中，新声明的类型和源类型共享底层类型。\n \n ```go\n"
                },
                {
                    "date": 1716173339579,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -97,9 +97,9 @@\n \n 规则：\n \n - 一个内置类型的底层类型为它自己。\n-- `unsafe`标准库包中定义的`Pointer`类型的底层类型是它自己。 `unsafe.Pointer`也被视为一个内置类型。\n+- `unsafe`标准库包中定义的`Pointer`类型的底层类型是它自己。`unsafe.Pointer`也被视为一个内置类型。\n - 一个无名类型（必为一个组合类型）的底层类型为它自己。\n - 在一个类型声明中，新声明的类型和源类型共享底层类型。\n \n ```go\n@@ -143,10 +143,8 @@\n - 组合字面量表示形式用来表示**结构体类型值**和**容器类型**（数组、切片和映射）值。\n \n ### 值部（value part）\n \n-> 这个术语并没有在 Go 白皮书中定义。它仅使用在 _《Go 语言 101》_ 这本书中，用来简化一些解释并帮助 Go 程序员更好地理解 Go 类型和值。\n-\n in run time, 很多值是存储在**内存**的。每个这样的值都有一个**直接部分**，但是有一些值还可能有一个或多个**间接部分**。每个值部分在内存中都占据一段连续空间。\n \n ### 值尺寸（value size）\n \n"
                },
                {
                    "date": 1716173355402,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -136,10 +136,8 @@\n 每个类型有一个零值。一个类型的零值可以看作是此类型的默认值。预声明的标识符 `nil` 可以看作是切片、映射、函数、通道、指针（包括非类型安全指针）和接口类型的零值的字面量表示。\n \n 值分为类型确定的和类型不确定的。\n \n-Go 中还有另外两种的字面量表示形式：函数字面量表示形式和组合字面量表示形式（composite literal）。\n-\n - 函数字面量表示形式用来表示函数值。事实上，一个函数声明是由一个**标识符**（函数名）和一个**函数字面量**表示形式组成。\n - 组合字面量表示形式用来表示**结构体类型值**和**容器类型**（数组、切片和映射）值。\n \n ### 值部（value part）\n"
                },
                {
                    "date": 1716173375128,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -136,10 +136,8 @@\n 每个类型有一个零值。一个类型的零值可以看作是此类型的默认值。预声明的标识符 `nil` 可以看作是切片、映射、函数、通道、指针（包括非类型安全指针）和接口类型的零值的字面量表示。\n \n 值分为类型确定的和类型不确定的。\n \n-- 函数字面量表示形式用来表示函数值。事实上，一个函数声明是由一个**标识符**（函数名）和一个**函数字面量**表示形式组成。\n-- 组合字面量表示形式用来表示**结构体类型值**和**容器类型**（数组、切片和映射）值。\n \n ### 值部（value part）\n \n in run time, 很多值是存储在**内存**的。每个这样的值都有一个**直接部分**，但是有一些值还可能有一个或多个**间接部分**。每个值部分在内存中都占据一段连续空间。\n"
                },
                {
                    "date": 1716173389345,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -130,9 +130,9 @@\n - 底层类型为内置类型`string`的类型称为**字符串类型**。\n \n ## 值（value）\n \n-一个类型的一个实例称为此类型的一个值。一个类型可以有很多不同的值，其中一个为它的零值。同一类型的不同值共享很多相同的属性。\n+一个类型的一个****实例**称为此类型的一个值。一个类型可以有很多不同的值，其中一个为它的零值。同一类型的不同值共享很多相同的属性。\n \n 每个类型有一个零值。一个类型的零值可以看作是此类型的默认值。预声明的标识符 `nil` 可以看作是切片、映射、函数、通道、指针（包括非类型安全指针）和接口类型的零值的字面量表示。\n \n 值分为类型确定的和类型不确定的。\n"
                },
                {
                    "date": 1716173405698,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -130,15 +130,14 @@\n - 底层类型为内置类型`string`的类型称为**字符串类型**。\n \n ## 值（value）\n \n-一个类型的一个****实例**称为此类型的一个值。一个类型可以有很多不同的值，其中一个为它的零值。同一类型的不同值共享很多相同的属性。\n+一个类型的一个**实例**称为此类型的一个值。一个类型可以有很多不同的值，其中一个为它的零值。同一类型的不同值共享很多相同的属性。\n \n 每个类型有一个零值。一个类型的零值可以看作是此类型的默认值。预声明的标识符 `nil` 可以看作是切片、映射、函数、通道、指针（包括非类型安全指针）和接口类型的零值的字面量表示。\n \n 值分为类型确定的和类型不确定的。\n \n-\n ### 值部（value part）\n \n in run time, 很多值是存储在**内存**的。每个这样的值都有一个**直接部分**，但是有一些值还可能有一个或多个**间接部分**。每个值部分在内存中都占据一段连续空间。\n \n"
                },
                {
                    "date": 1716173414494,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -136,18 +136,9 @@\n 每个类型有一个零值。一个类型的零值可以看作是此类型的默认值。预声明的标识符 `nil` 可以看作是切片、映射、函数、通道、指针（包括非类型安全指针）和接口类型的零值的字面量表示。\n \n 值分为类型确定的和类型不确定的。\n \n-### 值部（value part）\n \n-in run time, 很多值是存储在**内存**的。每个这样的值都有一个**直接部分**，但是有一些值还可能有一个或多个**间接部分**。每个值部分在内存中都占据一段连续空间。\n-\n-### 值尺寸（value size）\n-\n-> Go 白皮书没有规定非数值类型值的尺寸。\n-\n-一个值存储在内存中是要占据一定的空间的。此空间的大小称为此值的尺寸。值尺寸是用字节数来衡量的。 在 Go 中，当我们谈及一个值的尺寸，如果没有特殊说明，我们一般是指此值的直接部分的尺寸。 某个特定类别的所有类型的值的尺寸都是一样的。因为这个原因，我们也常将一个值的尺寸说成是它的类型的尺寸（或值尺寸）。\n-\n ## 其他概念\n \n ### 指针类型的基类型（base type）\n \n"
                },
                {
                    "date": 1716173433857,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -136,9 +136,8 @@\n 每个类型有一个零值。一个类型的零值可以看作是此类型的默认值。预声明的标识符 `nil` 可以看作是切片、映射、函数、通道、指针（包括非类型安全指针）和接口类型的零值的字面量表示。\n \n 值分为类型确定的和类型不确定的。\n \n-\n ## 其他概念\n \n ### 指针类型的基类型（base type）\n \n@@ -162,16 +161,16 @@\n 在 Go 中，我们可以给满足某些条件的类型（构造器）声明方法。方法也常被称为成员函数。一个类型的所有方法组成了此类型的**方法集**。\n \n ### 接口类型的动态类型和动态值\n \n-接口类型的值称为**接口值**。一个接口值可以包裹装载一个非接口值。_包裹在一个接口值中的非接口值称为此接口值的动态值_。此动态值的类型称为此接口值的动态类型。 一个什么也没包裹的接口值为一个零值接口值。零值接口值的动态值和动态类型均为不存在。\n+接口类型的值称为**接口值**。一个接口值可以包裹装载一个非接口值。*包裹在一个接口值中的非接口值称为此接口值的动态值*。此动态值的类型称为此接口值的动态类型。 一个什么也没包裹的接口值为一个零值接口值。零值接口值的动态值和动态类型均为不存在。\n 一个接口类型可以指定若干个（可以是零个）方法，这些方法形成了此接口类型的方法集。\n 如果一个类型（可以是接口或者非接口类型）的方法集是一个接口类型的方法集的超集，则我们说此类型实现了此接口类型。\n \n ### 一个值的具体类型（concrete type）和具体值（concrete value）\n \n 对于一个（类型确定的）非接口值，它的具体类型就是它的类型，它的具体值就是它自己。\n-一个 _零值接口值_ 没有具体类型和具体值。对于一个非零值接口值，它的具体类型和具体值就是它的动态类型和动态值。\n+一个 *零值接口值* 没有具体类型和具体值。对于一个非零值接口值，它的具体类型和具体值就是它的动态类型和动态值。\n \n ### 容器类型\n \n **数组** `[]int`、**切片** `slice` 和**映射** `map` 是 Go 中的三种正式意义上的内置容器类型。\n@@ -197,9 +196,9 @@\n ## 值得提的事\n \n ### 可比较类型和不可比较类型\n \n-目前（~~Go 1.21~~），下面这些类型的值不支持（使用 `==` 和 `!=` 运算标识符）比较。这些类型称为 _不可比较类型_。\n+目前（~~Go 1.21~~），下面这些类型的值不支持（使用 `==` 和 `!=` 运算标识符）比较。这些类型称为 *不可比较类型*。\n \n - 切片类型\n - 映射类型\n - 函数类型\n"
                },
                {
                    "date": 1716173464827,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -192,10 +192,8 @@\n - 一个可读可写的通道值也称为一个双向通道。 一个双向通道类型的底层类型可以被表示为`chan T`。\n - 我们只能向一个只写的通道值发送数据，而不能从其中接收数据。 只写通道类型的底层类型可以被表示为`chan<- T`。\n - 我们只能从一个只读的通道值接收数据，而不能向其发送数据。 只读通道类型的底层类型可以被表示为`<-chan T`。\n \n-## 值得提的事\n-\n ### 可比较类型和不可比较类型\n \n 目前（~~Go 1.21~~），下面这些类型的值不支持（使用 `==` 和 `!=` 运算标识符）比较。这些类型称为 *不可比较类型*。\n \n"
                },
                {
                    "date": 1716173475202,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,6 @@\n ---\n-title: 'DataType'\n+title: 'Go 语言中的数据结构'\n date: 2024-05-13T09:10:19+08:00\n draft: false\n taps: ['Golang', 'start']\n categories: ['Golang', 'CS']\n"
                },
                {
                    "date": 1716173480937,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,6 @@\n ---\n-title: 'Go 语言中的数据结构'\n+title: '数据结构和'\n date: 2024-05-13T09:10:19+08:00\n draft: false\n taps: ['Golang', 'start']\n categories: ['Golang', 'CS']\n"
                },
                {
                    "date": 1716173488460,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,6 @@\n ---\n-title: '数据结构和'\n+title: '数据结构和理论知识'\n date: 2024-05-13T09:10:19+08:00\n draft: false\n taps: ['Golang', 'start']\n categories: ['Golang', 'CS']\n"
                }
            ],
            "date": 1715565776498,
            "name": "Commit-0",
            "content": "---\ntitle: \"DataType\"\ndate: 2024-05-13T09:10:19+08:00\ndraft: true\ntaps: []\ncategories: []\nauthor: [\"Yeelight\"]\nshowtoc: true\nweight:\nmath: false\nreadingTime: true\n---\n\n\n## Go 语言中的数据结构\n### 基础数据结构\n\n 1. **数组（Array）** - 由固定长度的相同类型元素组成的数据结构。\n 2. **切片（Slice）** - 由数组构成的动态长度序列，提供了更灵活的操作方式。\n 3. **映射（Map）** - 存储键值对的集合，用于快速检索数据。\n 4. **结构体（Struct）** - 可以包含不同类型字段的复合数据类型。\n\n\n### 其他数据结构和类型\n\n1. **通道（Channel）** - 用于在 Go 协程之间进行通信的类型。\n2. **接口（Interface）** - 定义对象的行为，是一种抽象类型。\n3. **指针（Pointer）** - 存储变量的内存地址，用于直接访问内存中的值。\n\n#### 通道（Channel）\n#### 接口（Interface）\n#### 指针（Pointer）\n\n\n## 命名规范\n\n注意：\n> **首字母大小写：** 以大写字母开头的标识符是 **public** 的（可导出的），可以被其他包访问。以小写字母开头的标识符是私有的，只能在当前包内访问。\n\n在 Go 语言中，有一些命名规范适用于不同的命名情况。以下是一些常见的命名规范：\n\n1. **包名**：包名应该使用单数形式，且应该是小写的，例如 `utils`。\n2. **文件名**：文件名应该全部使用小写字母，可以包含下划线 `_`，例如 `my_file.go`。\n3. **变量**：变量名使用驼峰命名法，例如 `myVariable`。私有变量的命名应该以小写字母开头，公共变量则以大写字母开头。\n4. **常量**：常量的命名应该全部使用大写字母，可以包含下划线 `_`，例如 `MAX_SIZE`。\n5. **函数**：函数名同样使用驼峰命名法，例如 `calculateTotal`。\n6. **结构体**：结构体的命名同样使用驼峰命名法，例如 `type MyStruct struct`。\n7. **接口**：接口的命名同样使用驼峰命名法，例如 `type MyInterface interface`。\n8. **枚举**：枚举的命名同样使用驼峰命名法，例如 `type Color int`。\n\n\n在 Go 语言中，命名变量时有一些常见的命名规范，这些规范有助于编写清晰、易读的代码。\n\n1. 使用驼峰命名法：变量名应该使用驼峰命名法，即除第一个单词外，其余单词的首字母大写，例如 `myVariable`。\n2. 使用有意义的名称：变量名应该具有描述性，能够清晰地表达变量的用途和含义。\n3. 避免使用单个字符作为变量名：除非是临时变量或者循环变量，否则应该避免使用单个字符作为变量名，以提高代码的可读性。\n4. 使用短小的名称：变量名应该尽量简洁，但又能清晰表达变量的含义。\n5. 使用全大写命名的常量：在 Go 语言中，全大写的变量名通常用于表示常量。\n6. 遵循约定俗成的命名规范：Go 语言社区有一些常见的命名约定，比如用 `i` 表示循环变量，用 `err` 表示错误变量等，建议遵循这些约定以保持代码风格的一致性。\n\n这些命名规范有助于编写清晰、易读的代码，并且有助于提高代码的可维护性。\n\n"
        }
    ]
}