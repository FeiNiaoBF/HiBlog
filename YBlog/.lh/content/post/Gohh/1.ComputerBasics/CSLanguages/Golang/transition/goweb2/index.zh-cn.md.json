{
    "sourceFile": "content/post/Gohh/1.ComputerBasics/CSLanguages/Golang/transition/goweb2/index.zh-cn.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 6,
            "patches": [
                {
                    "date": 1718117713199,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1718117742154,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,6 @@\n ---\n-title: \"Go Web的学习1\"\n+title: \"Go Web的学习2\"\n date: 2024-06-11T22:45:30+08:00\n draft: false\n taps: ['web']\n categories: ['Golang', 'Web']\n@@ -9,4 +9,136 @@\n weight:\n math: false\n readingTime: true\n ---\n+\n+## Router 框架\n+> 大门管理员\n+### 路由功能\n+为了将代码模块化，而随之带来的另外一个问题是关于前端页面的跳转问题，由于代码的隔离，代码之间有时候会无法互相访问。因此需要一个**大门管理员**， Router 就此实现。\n+\n+它负责将传入的 HTTP 请求**映射（map）** 到相应的处理函数上。简单来说，路由决定了当用户访问一个特定的 URL 时，服务器应该执行哪些代码来处理这个请求。\n+\n+类似下面这样：\n+```go\n+type router struct {\n+    // map Handler function\n+    handlers map[string]HandlerFunc\n+}\n+```\n+\n+因此，路由要满足一下功能：\n+1. **URL匹配**：路由框架能够识别和匹配传入请求的URL，根据URL的不同部分（如路径、查询参数等）来决定调用哪个处理函数。\n+```go\n+func (r *router) handle(ctx *Context) {\n+    key := ctx.Method + \"-\" + ctx.Path\n+    if handler, ok := r.handlers[key]; ok {\n+       handler(ctx.Res, ctx.Req)\n+    } else {\n+       ctx.String(http.StatusNotFound, \"404 NOT FOUND: %s\\n\", ctx.Path)\n+    }\n+}\n+```\n+\n+2. **处理函数映射**：每个 URL 模式（pattern）都会被**映射**到一个或多个处理函数。当请求的 URL 匹配到某个模式时，相应的处理函数就会被调用。\n+```go\n+func (router *router) addRoute(method string, pattern string, handler HandlerFunc) {\n+    log.Printf(\"Route %4s - %s\", method, pattern)\n+    key := method + \"-\" + pattern\n+    router.handlers[key] = handler\n+}\n+```\n+\n+3. **参数提取**：对于**动态路由**，如 `/user/:id`，路由框架能够从 URL 中提取参数（如 `:id`），并将这些参数传递给处理函数。\n+4. **中间件支持**：路由框架通常支持中间件，这些中间件可以在请求到达**处理函数之前或之后**执行一些操作，如身份验证、日志记录等。\n+\n+### 主要点\n+\n+#### Query\n+\n+在HTTP请求的上下文中，`query` 通常指的是URL中的查询参数。查询参数是URL中`?`后面的键值对，它们用于向服务器传递额外的信息。例如，在URL `http://example.com/search?q=golang` 中，`q=golang` 就是一个查询参数，其中`q`是参数名，`golang`是参数值。\n+\n+#### Handler\n+\n+`Handler` 或 `Request Handler` 是指处理HTTP请求的函数或方法。在大多数后端框架中，包括Go语言的许多Web框架（如Gin、Echo、net/http等），`handler` 是一个函数，它接收HTTP请求并返回HTTP**响应**。\n+\n+### 封装\n+\n+在 Web 服务中，封装可以用来简化 HTTP**请求**和**响应**的处理。对于原始的方式需要手动设置 *HTTP Header*、*状态码*和*消息体* 等等，而封装后的方法则提供了一个更简洁的接口，只需调用一个函数就可以完成所有这些设置。\n+#### Context 结构\n+\n+在Web框架中，Context通常是一个结构体，它包含了处理HTTP请求和响应所需的所有信息。\n+\n+- **统一接口**：通过Context，可以将所有与请求相关的信息集中管理，使得处理函数和中间件可以方便地访问这些信息。\n+- **动态路由支持**：Context 可以存储动态路由解析后的参数，使得这些参数可以在处理函数中直接使用。[[#动态路由]]\n+- **中间件支持**：中间件可以在Context中添加或修改信息，这些信息可以被后续的处理函数使用。\n+\n+Context 随着每一个请求的出现而产生，请求的结束而销毁，和当前请求强相关的信息都应由 Context 承载。\n+\n+```go\n+// Context 结构体用于封装HTTP请求和响应的相关信息\n+type Context struct {\n+    Res http.ResponseWriter\n+    Req *http.Request\n+\n+    Path       string\n+    Method     string\n+    StatusCode int\n+}\n+```\n+在 Go 中的Context\n+#### API 设计\n+\n+🚧🚧🚧🚧🚧🚧🚧🚧🚧\n+### 动态路由\n+\n+动态路由是指路由中的某些部分是可变的，例如 `/hello/:name` 中的 `:name` 部分。当请求匹配到这个路由时，`:name` 会被替换为实际的值。在 Context 结构中，这些动态参数通常会被存储起来，以便在处理函数中使用。\n+\n+为了保存这些 `pattern` 我们有许多的协议和数据结构，常用 `Trie-Tree` 来作 pattern 的底层结构。\n+\n+\n+\n+了解 `pattern` 参数，其中 pattern 就是在路由器中预先定义的一组规则**模式** ，用来和用户输入的 URL 匹配。\n+\n+一般有三种模糊匹配路由规则：\n+1.  `:name` ---- **命名匹配规则**\n+2. `*any`   ---- **模糊匹配规**\n+3. `{field}` ---- **字段匹配规则**\n+\n+```go\n+type node struct {\n+\t//待匹配路由\n+\tpattern string\n+\t// important fields\n+\tpart     string\n+\tchildren []*node\n+\t// node color (isKey)\n+\t// *any | :xxx\n+\tisWildcard bool\n+}\n+\n+type PatRoot struct {\n+    root *node\n+}\n+```\n+\n+#### 要点\n+1. **Pattern（模式）**:\n+    - 模式是指在路由器中预先定义的一组规则，用于匹配传入的HTTP请求的URL路径。这些模式通常包含静态路径部分和动态路径部分（如参数或通配符）。例如，模式 `/user/:id` 表示一个用户详情页，其中 `:id` 是一个参数，可以匹配任何用户ID。\n+    - 在您的代码中，`pattern` 是 `router` 结构体中的一个字段，用于存储每个HTTP方法对应的路由树（`PatRoot`）。这些路由树是根据预定义的模式构建的，用于快速匹配传入的请求路径。\n+\n+2. **URL（统一资源定位符）**:\n+    - URL 是客户端（如浏览器）发送给服务器的实际请求路径。它是一个具体的字符串，指定了请求的资源在服务器上的位置。例如，`/user/123` 是一个URL，它请求ID为123的用户详情页。\n+    - 在您的代码中，`URL` 是通过 `Context` 对象传递的，它是处理HTTP请求时的一个关键部分。`getRoute` 方法使用这个URL来在路由树中查找匹配的模式\n+\n+\n+第一种是对 httpRouter 进行简单的封装，然后提供定制的中间件和一些简单的小工具集成比如 gin，主打轻量，易学，高性能。第二种是借鉴其它语言的编程风格的一些 MVC 类框架，例如 beego，方便从其它语言迁移过来的程序员快速上手，快速开发。还有一些框架功能更为强大，除了数据库 schema 设计，大部分代码直接生成，例如 goa。不管哪种框架，适合开发者背景的就是最好的。\n+\n+\n+\n+根据我们的经验，简单地来说，只要你的路由带有参数，并且这个项目的 API 数目超过了 10，就尽量不要使用 `net/http` 中默认的路由。\n+\n+\n+## 外部链接\n+\n+[router 请求路由](https://chai2010.cn/advanced-go-programming-book/ch5-web/ch5-02-router.html#52-router-%E8%AF%B7%E6%B1%82%E8%B7%AF%E7%94%B1)\n+\n"
                },
                {
                    "date": 1718117747771,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,9 +1,9 @@\n ---\n title: \"Go Web的学习2\"\n date: 2024-06-11T22:45:30+08:00\n draft: false\n-taps: ['web']\n+taps: ['web', '']\n categories: ['Golang', 'Web']\n author: [\"Yeelight\"]\n showtoc: true\n weight:\n@@ -140,5 +140,4 @@\n \n ## 外部链接\n \n [router 请求路由](https://chai2010.cn/advanced-go-programming-book/ch5-web/ch5-02-router.html#52-router-%E8%AF%B7%E6%B1%82%E8%B7%AF%E7%94%B1)\n-\n"
                },
                {
                    "date": 1718117757378,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,9 +1,9 @@\n ---\n title: \"Go Web的学习2\"\n date: 2024-06-11T22:45:30+08:00\n draft: false\n-taps: ['web', '']\n+taps: ['web', 'router']\n categories: ['Golang', 'Web']\n author: [\"Yeelight\"]\n showtoc: true\n weight:\n@@ -18,8 +18,9 @@\n \n 它负责将传入的 HTTP 请求**映射（map）** 到相应的处理函数上。简单来说，路由决定了当用户访问一个特定的 URL 时，服务器应该执行哪些代码来处理这个请求。\n \n 类似下面这样：\n+\n ```go\n type router struct {\n     // map Handler function\n     handlers map[string]HandlerFunc\n@@ -27,8 +28,9 @@\n ```\n \n 因此，路由要满足一下功能：\n 1. **URL匹配**：路由框架能够识别和匹配传入请求的URL，根据URL的不同部分（如路径、查询参数等）来决定调用哪个处理函数。\n+\n ```go\n func (r *router) handle(ctx *Context) {\n     key := ctx.Method + \"-\" + ctx.Path\n     if handler, ok := r.handlers[key]; ok {\n@@ -39,8 +41,9 @@\n }\n ```\n \n 2. **处理函数映射**：每个 URL 模式（pattern）都会被**映射**到一个或多个处理函数。当请求的 URL 匹配到某个模式时，相应的处理函数就会被调用。\n+\n ```go\n func (router *router) addRoute(method string, pattern string, handler HandlerFunc) {\n     log.Printf(\"Route %4s - %s\", method, pattern)\n     key := method + \"-\" + pattern\n@@ -84,8 +87,9 @@\n     Method     string\n     StatusCode int\n }\n ```\n+\n 在 Go 中的Context\n #### API 设计\n \n 🚧🚧🚧🚧🚧🚧🚧🚧🚧\n"
                },
                {
                    "date": 1718117817780,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,10 +11,13 @@\n readingTime: true\n ---\n \n ## Router 框架\n+>\n > 大门管理员\n+>\n ### 路由功能\n+\n 为了将代码模块化，而随之带来的另外一个问题是关于前端页面的跳转问题，由于代码的隔离，代码之间有时候会无法互相访问。因此需要一个**大门管理员**， Router 就此实现。\n \n 它负责将传入的 HTTP 请求**映射（map）** 到相应的处理函数上。简单来说，路由决定了当用户访问一个特定的 URL 时，服务器应该执行哪些代码来处理这个请求。\n \n@@ -27,8 +30,9 @@\n }\n ```\n \n 因此，路由要满足一下功能：\n+\n 1. **URL匹配**：路由框架能够识别和匹配传入请求的URL，根据URL的不同部分（如路径、查询参数等）来决定调用哪个处理函数。\n \n ```go\n func (r *router) handle(ctx *Context) {\n@@ -66,8 +70,9 @@\n \n ### 封装\n \n 在 Web 服务中，封装可以用来简化 HTTP**请求**和**响应**的处理。对于原始的方式需要手动设置 *HTTP Header*、*状态码*和*消息体* 等等，而封装后的方法则提供了一个更简洁的接口，只需调用一个函数就可以完成所有这些设置。\n+\n #### Context 结构\n \n 在Web框架中，Context通常是一个结构体，它包含了处理HTTP请求和响应所需的所有信息。\n \n@@ -89,59 +94,57 @@\n }\n ```\n \n 在 Go 中的Context\n+\n #### API 设计\n \n 🚧🚧🚧🚧🚧🚧🚧🚧🚧\n+\n ### 动态路由\n \n 动态路由是指路由中的某些部分是可变的，例如 `/hello/:name` 中的 `:name` 部分。当请求匹配到这个路由时，`:name` 会被替换为实际的值。在 Context 结构中，这些动态参数通常会被存储起来，以便在处理函数中使用。\n \n 为了保存这些 `pattern` 我们有许多的协议和数据结构，常用 `Trie-Tree` 来作 pattern 的底层结构。\n \n-\n-\n 了解 `pattern` 参数，其中 pattern 就是在路由器中预先定义的一组规则**模式** ，用来和用户输入的 URL 匹配。\n \n 一般有三种模糊匹配路由规则：\n-1.  `:name` ---- **命名匹配规则**\n+\n+1. `:name` ---- **命名匹配规则**\n 2. `*any`   ---- **模糊匹配规**\n 3. `{field}` ---- **字段匹配规则**\n \n ```go\n type node struct {\n-\t//待匹配路由\n-\tpattern string\n-\t// important fields\n-\tpart     string\n-\tchildren []*node\n-\t// node color (isKey)\n-\t// *any | :xxx\n-\tisWildcard bool\n+ //待匹配路由\n+ pattern string\n+ // important fields\n+ part     string\n+ children []*node\n+ // node color (isKey)\n+ // *any | :xxx\n+ isWildcard bool\n }\n \n type PatRoot struct {\n     root *node\n }\n ```\n \n #### 要点\n+\n 1. **Pattern（模式）**:\n     - 模式是指在路由器中预先定义的一组规则，用于匹配传入的HTTP请求的URL路径。这些模式通常包含静态路径部分和动态路径部分（如参数或通配符）。例如，模式 `/user/:id` 表示一个用户详情页，其中 `:id` 是一个参数，可以匹配任何用户ID。\n     - 在您的代码中，`pattern` 是 `router` 结构体中的一个字段，用于存储每个HTTP方法对应的路由树（`PatRoot`）。这些路由树是根据预定义的模式构建的，用于快速匹配传入的请求路径。\n \n 2. **URL（统一资源定位符）**:\n     - URL 是客户端（如浏览器）发送给服务器的实际请求路径。它是一个具体的字符串，指定了请求的资源在服务器上的位置。例如，`/user/123` 是一个URL，它请求ID为123的用户详情页。\n     - 在您的代码中，`URL` 是通过 `Context` 对象传递的，它是处理HTTP请求时的一个关键部分。`getRoute` 方法使用这个URL来在路由树中查找匹配的模式\n \n-\n 第一种是对 httpRouter 进行简单的封装，然后提供定制的中间件和一些简单的小工具集成比如 gin，主打轻量，易学，高性能。第二种是借鉴其它语言的编程风格的一些 MVC 类框架，例如 beego，方便从其它语言迁移过来的程序员快速上手，快速开发。还有一些框架功能更为强大，除了数据库 schema 设计，大部分代码直接生成，例如 goa。不管哪种框架，适合开发者背景的就是最好的。\n \n-\n-\n 根据我们的经验，简单地来说，只要你的路由带有参数，并且这个项目的 API 数目超过了 10，就尽量不要使用 `net/http` 中默认的路由。\n \n-\n ## 外部链接\n \n [router 请求路由](https://chai2010.cn/advanced-go-programming-book/ch5-web/ch5-02-router.html#52-router-%E8%AF%B7%E6%B1%82%E8%B7%AF%E7%94%B1)\n"
                },
                {
                    "date": 1718117828094,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -44,9 +44,9 @@\n     }\n }\n ```\n \n-2. **处理函数映射**：每个 URL 模式（pattern）都会被**映射**到一个或多个处理函数。当请求的 URL 匹配到某个模式时，相应的处理函数就会被调用。\n+2.**处理函数映射**：每个 URL 模式（pattern）都会被**映射**到一个或多个处理函数。当请求的 URL 匹配到某个模式时，相应的处理函数就会被调用。\n \n ```go\n func (router *router) addRoute(method string, pattern string, handler HandlerFunc) {\n     log.Printf(\"Route %4s - %s\", method, pattern)\n"
                },
                {
                    "date": 1718117834380,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -43,11 +43,10 @@\n        ctx.String(http.StatusNotFound, \"404 NOT FOUND: %s\\n\", ctx.Path)\n     }\n }\n ```\n+2. **处理函数映射**：每个 URL 模式（pattern）都会被**映射**到一个或多个处理函数。当请求的 URL 匹配到某个模式时，相应的处理函数就会被调用。\n \n-2.**处理函数映射**：每个 URL 模式（pattern）都会被**映射**到一个或多个处理函数。当请求的 URL 匹配到某个模式时，相应的处理函数就会被调用。\n-\n ```go\n func (router *router) addRoute(method string, pattern string, handler HandlerFunc) {\n     log.Printf(\"Route %4s - %s\", method, pattern)\n     key := method + \"-\" + pattern\n"
                }
            ],
            "date": 1718117713199,
            "name": "Commit-0",
            "content": "---\ntitle: \"Go Web的学习1\"\ndate: 2024-06-11T22:45:30+08:00\ndraft: false\ntaps: ['web']\ncategories: ['Golang', 'Web']\nauthor: [\"Yeelight\"]\nshowtoc: true\nweight:\nmath: false\nreadingTime: true\n---\n"
        }
    ]
}