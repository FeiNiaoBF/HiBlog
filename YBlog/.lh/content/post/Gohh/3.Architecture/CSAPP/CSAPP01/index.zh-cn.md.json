{
    "sourceFile": "content/post/Gohh/3.Architecture/CSAPP/CSAPP01/index.zh-cn.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1715560918203,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1715560918203,
            "name": "Commit-0",
            "content": "---\ntitle: \"一.数的表示(CSAPP)\"\ndate: 2023-03-19T20:13:06+08:00\ndraft: false\ntags: [CSAPP]\ncategories: [\"CSAPP\",\"CS\"]\nauthor: [\"Yeelight\"]\nshowtoc: true\nweight:\nreadingTime: true\n---\n\n# 二进制系统的核心---bit\n\n众所周知，在计算机里面的所以数据都是由**bit**表示的，可能这与我们日常使用的十进制来说是十分不方便的，而要想从现实世界的十进制到二进制的过程需要一点点的改变。\n<!--more-->\n\n正如我们所想的一样，bit的表示符合物理的形式，更加的底层，也与数学上的息息相关。当我们终究是要从程序员的看发来看bit的，对我们来说，计算机就是通过对**bit**进行不同方式的编码和描述，来完成和执行不同的任务。\n\n## 信息存储\n\n### 二进制和十六进制\n\n下面是各个进制的转换:\n\n| 二进制 | 十进制 | 十六进制 | 二进制 | 十进制 | 十六进制 |\n| :---: | :---: | :---: | :---: | :---: | :---: |\n| 0000 | 0 | 0 | 1000 | 8 | 8 |\n| 0001 | 1 | 1 | 1001 | 9 | 9 |\n| 0010 | 2 | 2 | 1010 | 10 | A |\n| 0011 | 3 | 3 | 1011 | 11 | B |\n| 0100 | 4 | 4 | 1100 | 12 | C |\n| 0101 | 5 | 5 | 1101 | 13 | D |\n| 0110 | 6 | 6 | 1110 | 14 | E |\n| 0111 | 7 | 7 | 1111 | 15 | F |\n\n这是一个十分重要的表格，我们要记得它。\n\n### 位， 字节， 字（bit, Byte, word）\n\n我们的一个位就是一bit， 一个字节就是8个bit， 一般32位字长机器一个字就是4个bit。\n\n如果你问我为什么要这么规定的话，我可以告诉你我也不知道，笑，可以去看看历史，我猜是这样的设计符合机器的一些特性。\n\n在C语言里面，所有的数据类型都有分配好的字节数，`char：1字节、short：2字节、int：4字节、long： 4字节、float：4字节、double：8字节`（均在32位机器上）等等。\n\n分配成这样：\n\n- 有规范，可以在不同的机器程序可以运行。\n- 机器没有无限大的内存。\n\n### 寻址和字节顺序\n\n在内存里，我们把它们抽象成一个一定大的数组块，为每一均匀分布的地址块编上编号(图片)，因此我们要知道多字节的存储顺序，这对于我们在进行网络数据的发送/接收格式，阅读反汇编的时候等等有关系。\n\n大小端的判定：\n\n以下是我使用书中的代码看我的电脑是大端还是小端：\n\n```c\n\ntypedef unsigned char *byte_pointer;\nvoid show_bytes(byte_pointer start, size_t len)\n{\n    size_t i;\n    for (size_t i = 0; i < len; i++)\n    {\n        printf(\"%.2x \", start[i]);\n    }\n    printf(\"\\n\");\n}\n\nvoid show_int(int x)\n{\n    show_bytes((byte_pointer)&x, sizeof(int));\n}\n\nint main(int argc, char const *argv[])\n\n{\n    short a = -12345;\n    unsigned short ua = a;\n    printf(\"number = %d\\n\", a);\n    show_int(a);\n    printf(\"number = %d\\n\", ua);\n    show_int(ua);\n    return 0;\n}\n\n==========================>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n$ ./byte\nnumber = -12345\nc7 cf ff ff\nnumber = 53191\nc7 cf 00 00\n\n// 我的电脑是小端的\n// 系统Linux: Alpine apk-tools 2.12.9, compiled for x86_64.\n\n```\n\n### 位的Boolean Algebras\n\n位的布尔运算可以看我的[这一篇](https://clever-klepon-d14cb6.netlify.app/posts/bitsoperation/)\n\n#### 左移和右移的计算\n\n这里我想着重的记下来：\n对于左移`<<`& 右移`>>` 是对于位的计算，相比于右移来说左移比较简单，在移动的同时往最低位右边补 0 即可。右移的话有两种类型，一种是`逻辑右移`（左边补 0），另一种是`算术右移`（左边补符号位）。为什么会有这两种，因为对应无符号数和有符号数的运算是不同的计算方法。\n\n### C语言上的logic计算\n\n不必多言，做题：\n\n```c\n// P76 练习题2.44\nint x = foo();\nint y = bar();\n\nunsigned ux = x;\nunsigned uy = y;\n\nx < 0           =>    ((x * 2) < 0)\nux >= 0\nx  & 7 == 7     =>    (x<<30) < 0\nux > -1\nx > y           =>    -x < -y\n\n```\n\n## 整数表示\n\n### 无符号表示\n\n无符号数（unsigned），就是在`0~2[^w] - 1`范围的数，w是表示字长。有一个重要的特性，就是每个介于0~2[^w]-1 之间的数都有唯一的一个w位的值编码。\n\n- UMin = 0;\n- UMax = 2[^w]−1;\n\n### 补码表示\n\n补码（Two' s Complement）， 就是在`-2[^w-1] ~ 2[^w-1] - 1`范围的数，补码的出现使得数据的表示得到最好的利用，在运算上和我们的计算自觉一样了，只有一个0没正负之分。\n\n- TMin = -2[^w-1]\n- TMax = 2[^w-1] - 1\n\n我们可以从上面得到一些特性：\n\n- |TMin|  = |TMax| + 1\n- UMax = 2 *|TMax| + 1  = 2* |TMin| - 1\n\n![B2Tx.png](https://s2.loli.net/2023/04/24/ZcUXbMrG2T4OJhP.png)\n\n## 整数运算\n\n### 加法\n\n考虑两个非负整数x 和y, 满足0 < x, y < 2[^w] 。每个数都能表示为w位无符号数字。然而，\n如果计算它们的和，我们就有一个可能的范围0 < x+y < 2[^w+1]-2 。我们需要`w+1`位\n\n| 8 | 11 | 3（19） |\n|:---:| :---: |:---:|\n|1000 | +  1011 |= 10011|\n\n我们来想想补码的形式，两个数x，y满足-2[^w-1] < x, y < 2[^w-1]-1,   计算它们的和，我们就有一个可能的范围-2[^w] < x + y < 2[^w-1]-2。\n\n| 8 | 11 | 3（19） |\n|:---:| :---: |:---:|\n|1000 | +  1011 |= 10011|\n\n### 乘法\n\n无符号数的乘法就是`UMul(x,y) = x * y mod 2[^w]`\n\n补码的乘法`TMul(x,y) = U2T(x * y mod 2[^w])`\n\n### 溢出\n\n在我们的运算中（特别是很大的数）不仅仅只考虑算不算的对，还要考虑有没有溢出，一旦我需要的位变成`w+1`的十分你要十分注意了。\n\n[![Two](https://s2.loli.net/2023/04/21/5iVANckMR9qseoZ.png)\n\n此时我们要用上扩展与截取：\n\n扩展：\n\n- 对于无符号数，用x位向量表示[xn-1,...,x0] ->[0,0,0,0,xn-1,...,x0],用0把剩下的位补齐\n- 对于补码， 用x位向量表示[xn-1,...,x0] ->[ xn-1,xn-1,xn-1,xn-1,...,x0],用`最高位xn-1`把剩下的位补齐\n截取：\n- 对于无符号数，UAdd(u,v) = u+v mod 2[^w], UMult(u,v)  = u * v mod 2[^w]\n- 对于补码，先把数转换成无符号数再模运算最后再转换补码， TAdd(u,v) = U2T(u+v mod 2[^w]), TMult(u,v)  = U2T(u * v mod 2[^w])\n\n### 类型转换\n\n无符号数和补码的转换是对位的表示不同来达到转换的过程。\n\n## 浮点数（floating point）\n\n关于浮点数，本质上就是我们如何使用二进制来表达一个很大或者很小的数 (类似科学计数法，但是编码上有显著的区别)。\n\n由于二进制的数值系统在表达能力上存在一定的限制 (位数的限制)，我们实际上没有办法表示所有的数，因此浮点数的设计需要认真的权衡和折中，既要考虑能够表达的范围，也要考虑表达的精度。\n\n浮点数是一种近似的数，和我们十进制中的小数（或分数）一样，比如：3/10 = 0.333！。所以浮点数在不论大小项目里面都是要十分小心的地方。\n\n### IEEE 浮点表示\n\nIEEE 浮点标准用V=(-1)[^s] *M* 2[^E]的形式来表示一个数：\n\n- 符号(sign) s 决定这数是负数(s=1) 还是正数(s=0), 而对于数值0的符号位解释\n作为特殊情况处理(-0.0 = +0.0)。\n- 尾数(significand) M 是一个二进制小数，它的范围是1~2-£, 或者是0~1 - £。\n- 阶码(exponent) E 的作用是对浮点数加权，这个权重是2 的E 次幕（可能是负数） 。\n将浮点数的位表示划分为三个字段，分别对这些值进行编码：\n- 一个单独的符号位s 直接编码符号s 。\n- k 位的阶码字段exp=ek - 1 … e1,e0 编码阶码E 。\n- n 位小数字段frac= fn-1 ... f1,f0 编码尾数M, 但是编码出来的值也依赖于阶码字\n段的值是否等千0 。\n\n![float.png](https://s2.loli.net/2023/04/24/TYMtb2kBysG6maf.png)\n\n在开始时记住一些值的来源：E = exp - Bias；M = 1/0 + f\n\n#### 规格化的值\n\n当阶数 `exp ≠ 000…0`和 `exp ≠ 111…1`时，表示的其实都是规范化的值，这里只需要大概知道因为实数轴上原来连续的值会被规范到有限的定值上并且这些定值之间的间距也是不一样的，具体可以通过后面给出的例子来理解。\n\n当 exp 的位模式既不全为0(数值0), 也不全为(32位的255，64位的2047)的时候，frac可以随意取值；\n\n- E = exp - Bias(2[^w-1] - 1)\n- M = 1 + f;\n\n例子：\n\n```\n    12345 = 0b0011.0000.0011.1001 = 1.1000000111001 * 2[^13]\n\n    E = 13 = exp - 127 -> exp = 140;\n    M = 1 + f = 1.1000000111001 -> f = 1000000111001;\n```\n\n|s(1)|exp(8)|frac(23)|\n|-|---|---|\n|0|10001100|10000001110010000000000|\n\n![Normalized](https://s2.loli.net/2023/04/24/FvmEjJeDSVWkQtH.jpg)\n\n#### 非规格化的值\n\n当exp每一位都为0的时候，可以想象到这时候的数无限的接近数值0，可画个数轴来看，此时的 `E = 1 - Bias`而且M没有隐含的1表示了，`M = f`\n\n第一个功能就是表示0，0的时候exp位为0，frac位为0，符号位的不同使得-0/+0有相同的地方何不同的地方。\n\n非规格化数的另外一个功能是表示那些非常接近于0.0 的数。它们提供了一种属性，称为逐渐溢出(gradual underflow), 其中，可能的数值分布均匀地接近于0.0 。\n\n![Denormalized](https://s2.loli.net/2023/04/24/ZmftLThWNq5kD4p.jpg)\n\n#### 无穷大和NaN\n\n最后一类数值是当指阶码全为1 的时候出现的。当小数域全为0时，得到的值表示无穷，当 s=O 时是 +∞ 或者是 s=1 时是 -∞ 。当我们把两个非常大的数相乘，或者除以零时，无穷能够表示溢出的结果。当小数域为非零时，结果值被称为\"NaN\", 即“不是一个数(**Not a Number**)\" 的缩写。一些运算的结果不能是实数或无穷，就会返回这样的NaN值，比如当计算sqrt(-1)或 (∞-∞) 时。在某些应用中，表示未初始化的数据时，它们也很有用处。\n\n![inf](https://s2.loli.net/2023/04/24/iYnoLHDCwqASEyg.jpg)\n![NaN](https://s2.loli.net/2023/04/24/15xlfajNMHpnrwG.jpg)\n\n#### 练习\n\n假设一个基于IEEE 浮点格式的5 位浮点表示，有1 个符号位、2 个阶 码位(k=Z) 和两个小数位(n=2) 。阶码偏置量是2[2-1] - 1 = 1 。下表中列举了这个5 位浮点表示的全部非负取值范围。使用下面的条件，填写表格中的空白项：\n\ne: 假定阶码字段是一个无符号整数所表示的值。\n\nE: 偏置之后的阶码值。\n\n2[^E]: 阶码的权重。\n\nf: 小数值。\n\nM: 尾数的值。\n\n2[^E] * M: 该数（未归约的）小数值。\n\nV: 该数归约后的小数值。\n\n十进制：该数的十进制表示。\n\n| 位 | e | E | 2[^E] | f | M | 2[^E]*M | V | 十进制 |\n|----|---|---|-------|---|---|---------|---|-------|\n|0 00 00 | 0 | 0 | 1 | 0/4 | 0/4 | 0/4 | 0   | 0.0 |\n|0 00 01 | 0 | 0 | 1 | 1/4 | 1/4 | 1/4 | 1/4 | 0.25 |\n|0 00 10 | 0 | 0 | 1 | 2/4 | 2/4 | 2/4 | 1/2 | 0.5 |\n|0 00 11 | 0 | 0 | 1 | 3/4 | 3/4 | 3/4 | 3/4 | 0.75 |\n|0 01 00 | 1 | 0 | 1 | 0/4 | 4/4 | 4/4 | 1 | 1.0 |\n|0 01 01 | 1 | 0 | 1 | 1/4 | 5/4 | 5/4 | 5/4 | 1.25 |\n|0 01 10 | 1 | 0 | 1 | 2/4 | 6/4 | 6/4 | 3/2 | 1.5 |\n|0 01 11 | 1 | 0 | 1 | 3/4 | 7/4 | 7/4 | 7/4 | 1.75 |\n|0 10 00 | 2 | 1 | 2 | 0/4 | 4/4 | 8/4 |  2  | 2.0 |\n|0 10 01 | 2 | 1 | 2 | 1/4 | 5/4 | 10/4 | 5/2 | 2.5 |\n|0 10 10 | 2 | 1 | 2 | 2/4 | 6/4 | 12/4 |  3  | 3.0 |\n|0 10 11 | 2 | 1 | 2 | 3/4 | 7/4 | 14/4 | 7/2 | 3.5 |\n|0 11 00 | - | - | - | - | - | - |  ∞  | - |\n|0 11 01 | - | - | - | - | - | - | NaN | - |\n|0 11 10 | - | - | - | - | - | - | NaN | - |\n|0 11 11 | - | - | - | - | - | - | NaN | - |\n\n### 浮点数的舍入\n\n### 溢出\n\n```c\nprintf(\"浮点数的溢出:\\n\\t\");\nprintf(\"(1e20 + (-1e20)) + 3.14 = %lf\\n\\t\", 1e20 + (-1e20) + 3.14);\nprintf(\"1e20 + (-1e20 + 3.14) = %lf\\n\", 1e20 + (-1e20 + 3.14));\n   \n```\n\n### 浮点数的加乘法\n\n浮点数的加乘法是和我们想的不一样的，它不满足结合律，交换律的，如下：\n\n```c\nx = a + b + c;\ny = b + c + d;\n\n// 编译器可能试图通过产生下列代码来省去一个浮点加法\nt = b + c;\nx = a + t;\ny = t + d;\n// 但是对x来说，这个计算可能会产生于原始值不同的值,因为它使用了加法运算的不同结合方式\n\n//浮点数的溢出:\n   (1e20  + (-1e20)) + 3.14  =  3.140000\n    1e20  + (-1e20   + 3.14) =  0.000000\n```\n\n## 总结\n\n这一章我们具体的学习了在机器上数的表示，我们用无符号数和补码来表示我的数值，用浮点数表示二进制的科学计数法，数与数的计算，它们是会有溢出的，用模运算来截断防止位溢出。\n大多数C 语言实现遵循的原则是底层的位模式不变。在补码机器上，对于一个w 位的值，这种行为是由函数T2Uw 和U2Tw来描述的。C 语言隐式的强制类型转换会出现许多程序员无法预计的结果，常常导致程序错误。\n\n```c\n\nint y = (int)(double)y;\n\n```\n\n我的建议是通读一遍课本，课本比我写的好很多，我想表达的写不出来那个`味道`，而后再去看看视频会更加的理解。\n\n## 外部链接\n\n[IEEE754---wiki](https://en.wikipedia.org/wiki/IEEE_754)\n[浮点数---wiki](https://zh.wikipedia.org/wiki/%E6%B5%AE%E7%82%B9%E6%95%B0)\n"
        }
    ]
}